program gload;

uses
	DOM,
	XMLRead,
	Classes,
	Sysutils,
	Strutils;

var
	Doc : TXMLDocument;
	DocChild : TDOMNode;
	DocElem : TDOMElement;
	Content : String;
	ContentOld : String;
	ContentOld2 : String;
	Commands : Array of String;
	Versions : Array of String;
	I : Integer;

const
	Prefix : String = 'gload_';
	VersionMax : String = '1.1';

procedure Add(S : String);
begin
	Content := Content + S;
end;

procedure AddLn(S : String);
begin
	Add(S + #10);
end;

procedure AddLn();
begin
	AddLn('');
end;

function GLEnum(Name : String) : String;
var
	Child : TDOMNode;
	ChildElem : TDOMElement;
	Child2 : TDOMNode;
	Child2Elem : TDOMElement;
begin
	Child := Doc.DocumentElement.FirstChild;
	GLEnum := '';
	while Assigned(Child) do
	begin
		if Child.NodeName = 'enums' then
		begin
			ChildElem := TDOMElement(Child);
			if ChildElem.GetAttribute('namespace') = 'GL' then
			begin
				Child2 := ChildElem.FirstChild;
				while Assigned(Child2) do
				begin
					if Child2.NodeName = 'enum' then
					begin
						Child2Elem := TDOMElement(Child2);
						if String(Child2Elem.GetAttribute('name')) = Name then
						begin
							GLEnum := String(Child2Elem.GetAttribute('value'));
							AddLn('#define ' + Name + ' ' + GLEnum);
							exit;
						end;
					end;
					Child2 := Child2.NextSibling;
				end;
			end;
		end;
		Child := Child.NextSibling;
	end;
end;

procedure GLCommand(Name : String);
var
	Child : TDOMNode;
	ChildElem : TDOMElement;
	Child2 : TDOMNode;
	Child3 : TDOMNode;
	ReturnName : String;
	Args : String;
begin
	Child := Doc.DocumentElement.FirstChild;
	while Assigned(Child) do
	begin
		if Child.NodeName = 'commands' then
		begin
			ChildElem := TDOMElement(Child);
			if ChildElem.GetAttribute('namespace') = 'GL' then
			begin
				Child2 := ChildElem.FirstChild;
				while Assigned(Child2) do
				begin
					if Child2.NodeName = 'command' then
					begin
						if String(Child2.FindNode('proto').FindNode('name').TextContent) = Name then
						begin
							if Assigned(Child2.FindNode('proto').FindNode('ptype')) then
							begin
								ReturnName := String(Child2.FindNode('proto').FindNode('ptype').TextContent);
							end
							else
							begin
								ReturnName := 'void';
							end;

							Args := '';

							Child3 := Child2.FirstChild;
							while Assigned(Child3) do
							begin
								if Child3.NodeName = 'param' then
								begin
									if Length(Args) > 0 then
									begin
										Args := Args + ', ';
									end;
									Args := Args + String(TDOMText(Child3).TextContent);
								end;
								Child3 := Child3.NextSibling;
							end;

							if Length(Args) = 0 then
							begin
								Args := 'void';
							end;

							AddLn('#define ' + Name + ' ' + Prefix + Name);
							AddLn('typedef ' + ReturnName + '(APIENTRYP PFN' + UpperCase(Name) + 'PROC)(' + Args + ');');
							AddLn('GLAPI PFN' + UpperCase(Name) + 'PROC ' + Prefix + Name + ';');
							AddLn();
							exit;
						end;
					end;
					Child2 := Child2.NextSibling;
				end;
			end;
		end;
		Child := Child.NextSibling;
	end;
end;

procedure GLAPI(Node : TDOMNode);
var
	Child : TDOMNode;
begin
	Child := Node.FindNode('require').FirstChild;
	while Assigned(Child) do
	begin
		if Child.NodeName = 'enum' then
		begin
			GLEnum(String(TDOMElement(Child).GetAttribute('name')));
		end
		else if Child.NodeName = 'command' then
		begin
			SetLength(Commands, Length(Commands) + 1);
			Commands[Length(Commands) - 1] := String(TDOMElement(Child).GetAttribute('name'));
			GLCommand(String(TDOMElement(Child).GetAttribute('name')));
		end;
		Child := Child.NextSibling;
	end;
end;

procedure ReadXMLFilePreserveWhitespace(out Doc: TXMLDocument; FileName: string);
var
	Parser: TDOMParser;
	Src: TXMLInputSource;
	InFile: TFileStream;
begin
	try
		InFile := TFileStream.Create(FileName, fmOpenRead);
		Src := TXMLInputSource.Create(InFile);
		Parser := TDOMParser.Create;
		Parser.Options.PreserveWhitespace := True;
		Parser.Parse(Src, Doc);
	finally
		Src.Free;
		Parser.Free;
		InFile.Free;
	end;
end;

(* I mean... Version shouldn't become like 1.100 *)
function GLEqualOrLower(InputVer : String; TargetVer : String) : Boolean;
var
	InputI : Integer;
	TargetI : Integer;
begin
	InputI := StrToInt(Copy(InputVer, 1, 1)) * 10 + StrToInt(Copy(InputVer, 3, 1));
	TargetI := StrToInt(Copy(TargetVer, 1, 1)) * 10 + StrToInt(Copy(TargetVer, 3, 1));
	GLEqualOrLower := InputI <= TargetI;
end;

begin
	Content := '';
	SetLength(Commands, 0);
	SetLength(Versions, 0);

	AddLn('/**');
	AddLn(' * OpenGL loader generated by gload.');
	ContentOld := Content;
	Content := '';
	AddLn(' */');
	AddLn();
	
	AddLn('#ifndef __gload_h__');
	AddLn('#define __gload_h__');
	AddLn();

	AddLn('#define __gl_h_');
	AddLn();

	AddLn('#ifdef _WIN32');
	AddLn('#define APIENTRY __stdcall');
	AddLn('#endif');
	AddLn();

	AddLn('#ifndef APIENTRY');
	AddLn('#define APIENTRY');
	AddLn('#endif');
	AddLn();

	AddLn('#ifndef APIENTRYP');
	AddLn('#define APIENTRYP APIENTRY*');
	AddLn('#endif');
	AddLn();

	AddLn('#ifndef GLAPIENTRY');
	AddLn('#define GLAPIENTRY GLAPIENTRY');
	AddLn('#endif');
	AddLn();

	AddLn('#ifndef GLAPI');
	AddLn('#define GLAPI extern');
	AddLn('#endif');
	AddLn();

	AddLn('#ifdef __cplusplus');
	AddLn('extern "C" {');
	AddLn('#endif');
	AddLn();

	AddLn('typedef unsigned int GLenum;');
	AddLn('typedef unsigned char GLboolean;');
	AddLn('typedef unsigned int GLbitfield;');
	AddLn('typedef int GLsizei;');
	AddLn('typedef GLsizei* GLsizeiptr;');
	AddLn('typedef float GLfloat;');
	AddLn('typedef float GLclampf;');
	AddLn('typedef double GLdouble;');
	AddLn('typedef double GLclampd;');
	AddLn('typedef void GLvoid;');
	AddLn('typedef char GLchar;');
	AddLn();

	AddLn('typedef signed char GLbyte;');
	AddLn('typedef signed short GLshort;');
	AddLn('typedef int GLint;');
	AddLn('typedef GLint* GLintptr;');
	AddLn();

	AddLn('typedef unsigned char GLubyte;');
	AddLn('typedef unsigned short GLushort;');
	AddLn('typedef unsigned int GLuint;');
	AddLn();

	AddLn('GLAPI void ' + Prefix + 'init(void);');

	ReadXMLFilePreserveWhitespace(Doc, 'gl.xml');
	DocChild := Doc.DocumentElement.FirstChild;
	while Assigned(DocChild) do
	begin
		if DocChild.NodeName = 'feature' then
		begin
			DocElem := TDOMElement(DocChild);
			if (DocElem.GetAttribute('api') = 'gl') and GLEqualOrLower(String(DocElem.GetAttribute('number')), VersionMax) then
			begin
				SetLength(Versions, Length(Versions) + 1);
				Versions[Length(Versions) - 1] := String(DocElem.GetAttribute('number'));
				AddLn('/***** OpenGL ' + String(DocElem.GetAttribute('number')) + ' *****/');
				AddLn('#define ' + String(DocElem.GetAttribute('name')));
				GLAPI(DocChild);
				AddLn();
			end;
		end;
		DocChild := DocChild.NextSibling;
	end;

	AddLn('#ifdef GLOAD_IMPLEMENTATION');
	for I := 0 to (Length(Commands) - 1) do
	begin
		AddLn('PFN' + UpperCase(Commands[I]) + 'PROC ' + Prefix + Commands[I] + ';');
	end;
	AddLn();
	AddLn('#include <stddef.h>');
	AddLn('#ifdef _WIN32');
	AddLn('#include <windows.h>');
	AddLn('#else');
	AddLn('#include <dlfcn.h>');
	AddLn('#endif');
	AddLn('static void* ' + Prefix + 'gl = NULL;');
	AddLn();
	AddLn('void* ' + Prefix + 'load(const char* name){');
	AddLn('#ifdef _WIN32');
	AddLn('	return GetProcAddress(' + Prefix + 'gl, name);');
	AddLn('#else');
	AddLn('	return dlsym(' + Prefix + 'gl, name);');
	AddLn('#endif');
	AddLn('}');
	AddLn();
	AddLn('void ' + Prefix + 'init(void){');
	AddLn('#ifdef _WIN32');
	AddLn('	const char* names[] = {"opengl32.dll"};');
	AddLn('#else');
	AddLn('	const char* names[] = {"libGL.so"};');
	AddLn('#endif');
	AddLn('	int i;');
	AddLn('	if(' + Prefix + 'gl != NULL) return;');
	AddLn('	for(i = 0; i < sizeof(names) / sizeof(names[0]); i++){');
	AddLn('#ifdef _WIN32');
	AddLn('		' + Prefix + 'gl = LoadLibraryA(names[i]);');
	AddLn('#else');
	AddLn('		' + Prefix + 'gl = dlopen(names[i], RTLD_LAZY);');
	AddLn('#endif');
	AddLn('		if(' + Prefix + 'gl != NULL) break;');
	AddLn('	}');
	AddLn('	if(' + Prefix + 'gl == NULL) return;');
	for I := 0 to (Length(Commands) - 1) do
	begin
		AddLn('	' + Prefix + Commands[I] + ' = (PFN' + UpperCase(Commands[I]) + 'PROC)' + Prefix + 'load("' + Commands[I] + '");');
	end;
	AddLn('}');
	AddLn('#endif');
	AddLn();

	AddLn('#ifdef __cplusplus');
	AddLn('}');
	AddLn('#endif');

	ContentOld2 := Content;
	Content := '';

	AddLn(' *');
	AddLn(' * Versions:');
	for I := 0 to (Length(Versions) - 1) do
	begin
		AddLn(' *   OpenGL ' + Versions[I]);
	end;

	AddLn(' *');
	AddLn(' * Commands:');
	for I := 0 to (Length(Commands) - 1) do
	begin
		AddLn(' *   ' + Commands[I]);
	end;

	Content := ContentOld + Content + ContentOld2;

	AddLn('#endif');

	WriteLn(Content);
end.
